package leetCode.moderately;

/**
 * @author: gj
 * @description: 97. 交错字符串
 */
public class IsInterleave {
    /**
     * 思路：
     * 1、首先，想最简单的，如果s1和s2串组成s3串中，分割的子串各不相同，即组成s3串某一段子串时，必须采用s1或s2之一的子串，而不是s1和s2的子串都可以。
     * - 例如：
     * - 例子0：对于s1="abc",s2="dab", s3="abcdab"，对于这种情况，最开始只能采用s1的子串"abc"，然后采用s2的dab。
     * - 例子1：对于s1="abcde",s2="abkfg", s3="ababcdefg"，对于这种情况，s1、s2、s3最开始的子串均为"ab"，不知道该第一个到底是采用s1还是s2。
     * - 例子2：对于s1="aaa",s2="aaa", s3="aaaaaa"，对于这种情况，s1、s2、s3最开始的子串均为多个a，不知道该第一个到底是采用s1还是s2，采用几个a。
     * - 对于例子0而言，只需要尽可能贪心的将当前串向后扩展对比s3即可。
     * - 然而，对于例子1和例子2，使得我们不得尝试不同分支，然后回退。
     * 2、根据上面分析，我们可以递归回溯处理：
     * - 设：i 指向 s1 当前的位置，j 指向 s2 当前的位置，k 指向 s3 当前的位置
     * - 如果 s1[i] == s3[k]：尝试走 (i+1, j)，如果 s2[j] == s3[k]：尝试走 (i, j+1)
     * 3、然后会发现，上述回溯存在大量的重复子问题：
     * - 例子：s1 = "aa"，s2 = "aa"，s3 = "aaaa"
     * - 我们用dfs(i,j)表示：当前使用了 s1 的前 i 个字符，s2 的前 j 个字符，组成了 s3 的前 k=i+j 个字符
     * - 那么当前例子的递归树如下：
     * -                 (0,0)
     * -           /               \
     * -        (1,0)             (0,1)
     * -       /     \           /     \
     * -    (2,0)   (1,1)    (1,1)     (0,2)
     * -            /   \      /   \
     * -         (2,1) (1,2) (2,1) (1,2)
     * - 可以发现：重复节点非常明显，(1,1) 出现了 2 次，(2,1) 出现了 2 次，，(1,2) 出现了 2 次
     * 4、因此可以尝试记忆化搜索，在递归过程中记录每个(i，j)组合是否计算过
     * - 然后就会发现，回溯过程中唯一重要的状态是：目前已经使用了 s1 的前 i 个字符，和 s2 的前 j 个字符。
     * - 至于分了多少段、交替了几次，都不重要！
     * - 我们只需要知道使用了 s1 的前 i 个字符，和 s2 的前 j 个字符可以组成 s3 的前 k 个字符。
     * - 剩余能不能成功，与之前的路径无关。
     * 5、既然和前面状态无关，记忆化自上而下的搜索，自然也可以自下而上的动态规划处理。
     * - 我们只需要知道dp[i][j]，即使用了 s1 的前 i 个字符，和 s2 的前 j 个字符，能否组成 s3 的前 k=i+j 个字符。
     * - 至于这前k个怎么组成的不需要关心。
     * - 然后继续组成s3的第k+1个字符即可。
     * - 最终，状态转移方程：s3[k] = s1[i]，当前字符可以取s1[i]，那么前置状态就是dp[i-1][j]，即s1的前i-1个字符和s2的前j个字符可以组成s3的前k-1个字符。
     * - dp[i][j] = dp[i-1][j] && s1.charAt(i-1) == s3.charAt(i+j-1) || dp[i][j-1] && s2.charAt(j-1) == s3.charAt(i+j-1)
     * 注意：
     * - 不用可以去处理交替顺序，因为s1和s2的子串长度可以是任意长度。
     * - 如果 s3 是“交错”组成的，那么它一定能被分为若干非空段，段之间来自 s1 / s2，且段数量差不超过 1。
     */
    public boolean isInterleave(String s1, String s2, String s3) {
        int m = s1.length();
        int n = s2.length();
        if (m + n != s3.length()) {
            return false;
        }
        // dp[i][j] 表示 s1 前 i 个字符和 s2 前 j 个字符能否组成 s3 前 i+j 个字符
        boolean[][] dp = new boolean[m + 1][n + 1];
        // 初始化空字符串组合
        dp[0][0] = true;
        // 初始化第一列，只能由 s1 构成
        for (int i = 1; i <= m; i++) {
            dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);
        }
        // 初始化第一行，只能由 s2 构成
        for (int j = 1; j <= n; j++) {
            dp[0][j] = dp[0][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);
        }
        // 填充 dp 表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 当前位置可以由 s1 的前 i 个字符拼出
                if (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) {
                    dp[i][j] = true;
                }
                // 当前位置可以由 s2 的前 j 个字符拼出
                if (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1)) {
                    dp[i][j] = true;
                }
            }
        }
        // 最终结果表示 s1 全部 + s2 全部能否组成 s3
        return dp[m][n];
    }
}
