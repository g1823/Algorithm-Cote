package leetCode.moderately;

/**
 * @author: gj
 * @description: 172. 阶乘后的零
 */
public class TrailingZeroes {
    /**
     * 计算 n! 尾部有多少个 0（方法注释，包含从错误思路到正确推导的完整思考过程）。
     * <p>
     * 起点（你的直觉观察）：
     * - 直观想法：末尾 0 来自 10=2*5，于是认为可以通过观察个位/每 10/每 100 来计数。
     * 举例你的初始计数法（直觉版）：
     * - 认为每 10 个数会出现 2 个 0（因为每个 10 的倍数直接贡献 1 个 0，加上其他个位是 5 的数与某个偶数相乘会出现 0）；
     * - 进一步猜测每 100 个数会出现 21 个 0，每 1000 个出现 211 个 0（你是在按“每 10 倍增一个基数”向上累加）；
     * - 这个直觉在 n 较小或不包含高次 5 的时候可能“巧合正确”（例如 n=22），所以看起来有道理。
     * <p>
     * 为什么直觉会出错（核心漏洞）：
     * - 直觉只把“含一个 5 的数”当成 1 个 5 来处理，等同于只用了 floor(n / 5) 这一项；
     * - 但某些数（25, 125, ...）含有 **多个** 因子 5（例如 25 = 5*5），这些数会贡献 **额外的** 5，而你的“每 10 / 每 100”线性计数法没有把这些额外的 5 单独计入；
     * - 当区间包含 25、50、75、100、125... 时，会产生额外的 5 的贡献，导致直觉计数被低估。
     * - 反例说明（用于面试说明错误）：n = 100
     * - 直觉（你给出的“每 100 出现 21 个 0”）：21（错误）
     * - 正确计算：floor(100/5) + floor(100/25) = 20 + 4 = 24（正确）
     * - 少掉的 3 个 0 来自于 25、50、75、100 等能够额外贡献 5 的数。
     * <p>
     * 正确的关键观察（从因子分解出发）：
     * - n! = 1 * 2 * 3 * ... * n。对每个项做质因数分解，把所有因子 5 单独数出来；
     * - 每个能被 5 整除的数至少贡献 1 个 5（计入 floor(n/5)）；
     * - 每个能被 25 (=5^2) 整除的数再额外贡献 1 个 5（计入 floor(n/25)）；
     * - 每个能被 125 (=5^3) 整除的数再额外贡献 1 个 5（计入 floor(n/125)），以此类推。
     * - 因此总的 5 的个数为：
     * floor(n/5) + floor(n/25) + floor(n/125) + ...
     * 这个和就是 n! 中 5 因子的总数，因而等于末尾 0 的个数（2 的因子充足）。
     * <p>
     * 为什么实现可以写成 while (n > 0) { n /= 5; count += n; }：
     * - 首次执行 n /= 5 得到 floor(original_n/5)，代表“含 >=1 个 5 的数”的数量；
     * - 将 n 赋为 floor(original_n/5) 后再次 n /= 5 就得到 floor(original_n/25)，代表“含 >=2 个 5 的数”的数量（这些数每个额外贡献一个 5）；
     * - 重复该过程会依次得到 floor(original_n/5^k)（k = 1,2,3,...），直到 5^k > original_n 时结果为 0；
     * - 把每轮的结果累加正好等于 floor(n/5) + floor(n/25) + ...，即 5 的总个数。
     * - 这一写法有两个好处：
     * 1. 避免了显式计算 5^k（可能溢出）的风险；
     * 2. 复杂度低，为 O(log_5 n)，空间 O(1)。
     * <p>
     * 面试答题建议（如何口述你的思路）：
     * 1. 先说你的直觉（“我最开始按每 10、每 100 统计过，觉得会这样增长”），并举一个 n=22 等能说明直觉什么时候对的例子；
     * 2. 接着指出反例（n=100）展示直觉的缺陷：忽略了 25,125 等高次 5 的额外贡献；
     * 3. 给出因子分解的正确思路并写出公式 floor(n/5) + floor(n/25) + ...；
     * 4. 说明实现技巧：用 n /= 5 累加代替显式计算 5^k；
     * 5. 最后给出简洁代码并说明复杂度与边界（n=0 返回 0）。
     * <p>
     * 复杂度：O(log_5 n) 时间，O(1) 空间。
     */
    public int trailingZeroes(int n) {
        int count = 0;
        // 每轮 n /= 5 实际上是在计算 floor(original_n / 5^k)（k=1,2,3,...）
        while (n > 0) {
            // 第 k 轮得到 floor(original_n / 5^k)
            n /= 5;
            // 累加每一轮对“因子 5”贡献的数量
            count += n;
        }
        return count;
    }

}
