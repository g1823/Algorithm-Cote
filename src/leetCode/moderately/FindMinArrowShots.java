package leetCode.moderately;

import java.util.Arrays;
import java.util.Comparator;

/**
 * @author: gj
 * @description: 452. 用最少数量的箭引爆气球
 * * 方法对比：交集法（左端点） vs 贪心法（右端点）
 * * ------------------------------------
 * * 题意：
 * * 找到最少箭数，使得每支箭都能射中一批重叠的气球。
 * *
 * * 1. 交集法（按左端点排序）
 * *    - 排序方式：按每个气球区间的左端点升序。
 * *    - 算法思想：
 * *        • 从左到右遍历区间，维护当前交集区间 [start, end]。
 * *        • 遇到新区间：
 * *            - 如果与交集有重叠 → 更新交集为二者交集 [max(start, curStart), min(end, curEnd)]
 * *            - 如果无重叠 → 当前交集完成，新开一箭，并将交集重置为新区间。
 * *    - 状态维护：只需维护一个当前交集即可。
 * *    - 算法核心：每支箭对应交集区间，交集缩小表示箭能覆盖所有重叠区间。
 * *    - 优点：直观反映箭能覆盖的区间范围。
 * *
 * * 2. 贪心法（按右端点排序）
 * *    - 排序方式：按每个气球区间的右端点升序。
 * *    - 算法思想：
 * *        • 遍历排序后的区间，每次在当前未被射中区间的右端点射箭。
 * *        • 如果新区间的左端点 > 当前箭位置 → 新开一箭并更新箭位置。
 * *        • 否则该区间被当前箭覆盖，无需操作。
 * *    - 状态维护：只需维护当前箭的位置 currentMax。
 * *    - 算法核心：每支箭射在最右端点，覆盖尽可能多的重叠区间。
 * *    - 优点：代码简洁，效率高。
 * *
 * * 3. 等价性说明
 * *    - 两者得到的最少箭数一定相同。
 * *    - 原因：
 * *        • 交集法维护的交集表示当前箭必须覆盖的公共范围；
 * *        • 贪心法选择最右端点射箭，也保证覆盖所有与该箭重叠的区间。
 * *        • 本质上都是在分组所有重叠区间，每组只需要一箭。
 * *
 * * 4. 时间复杂度：O(n log n) （排序耗时）
 * * 5. 空间复杂度：O(1)
 */
public class FindMinArrowShots {


    public static void main(String[] args) {
        int[][] points = {{9, 12}, {1, 10}, {4, 11}, {8, 12}, {3, 9}, {6, 9}, {6, 7}};
        System.out.println(findMinArrowShots(points));
    }

    /**
     * 取交集（左端排序）
     * 思路说明：
     * ------------
     * 题意是找到最少的箭数，使得每支箭都能射穿一批有重叠的气球区间。
     * 解题本质：区间重叠分组问题。
     * -    每组能被同一支箭射中的气球，它们的区间必须存在非空交集。
     * -    因此，可以把所有区间按 start 升序排序，
     * -    从左到右维护当前所有能被同一箭射中的区间的“交集范围” [start, end]。
     * 算法步骤：
     * 1. 按左端点升序排序（这样每次遇到新区间时，其左端点不会小于上一个）。
     * 2. 初始化第一个交集区间 [start, end] = 第一个气球区间。
     * 3. 遍历剩余区间：
     * -       若当前区间的 start > end，说明与当前交集无重叠；
     * -       需要新开一支箭（res++），并将交集更新为当前区间。
     * -       否则说明存在重叠，
     * -       更新交集为二者交集 [max(start, curStart), min(end, curEnd)]。
     * 4. 遍历结束后，res 即为最少箭数。
     * 为什么取交集可行：
     * -    当前交集 [start, end] 表示一支箭可命中的所有气球的共同区域。
     * -    若后续气球与该交集仍有重叠，则它必然能被这支箭命中；
     * -      我们继续更新交集以缩小“必须射中的共同范围”。
     * -    若后续气球完全不重叠，则当前交集对应的那支箭“闭合”，
     * -      只能新开一组（新箭）。
     * 为什么可以只保留最后一个交集：
     * -    因为当前交集区间已经概括了“当前这支箭能命中的所有气球”的公共部分，
     * -    任何被覆盖的气球无需再单独存储；
     * -    一旦出现不重叠，新交集重置即可。
     * -    因此无需维护交集列表，只需维护一个当前交集。
     * 时间复杂度：O(n log n) （排序耗时）
     * 空间复杂度：O(1)
     */
    public static int findMinArrowShots(int[][] points) {
        if (points.length == 0) {
            return 0;
        }
        // 1. 按左端点升序排序，方便后续顺序遍历判断重叠
        Arrays.sort(points, Comparator.comparingInt(a -> a[0]));
        int n = points.length;
        // 当前交集的左右边界
        int start = points[0][0];
        int end = points[0][1];
        // 至少需要一支箭
        int res = 1;
        for (int i = 1; i < n; i++) {
            // 当前气球区间的起点大于交集的终点 → 无重叠，需要新箭
            if (points[i][0] > end) {
                res++;
                // 重置交集为当前气球区间
                start = points[i][0];
                end = points[i][1];
            } else {
                // 否则有重叠，更新交集为二者交集
                start = Math.max(start, points[i][0]);
                end = Math.min(end, points[i][1]);
            }
        }
        return res;
    }

    /**
     * 贪心法（按右端点排序）
     * 题意：找到最少箭数，使得每支箭尽可能射中尽可能多的气球。
     * 核心思想：
     * -  - 将气球区间按右端点升序排序；
     * -  - 每次选择当前未被射中区间的最小右端点作为箭的位置；
     * -  - 这样可以保证：
     * -      1. 当前箭覆盖尽可能多的区间（因为右端点最小的气球先被射中）；
     * -      2. 后续与当前箭有重叠的气球自然被覆盖，无需额外箭。
     * 算法步骤：
     * 1. 按右端点排序；
     * 2. 初始化箭数 res = 1，当前箭位置 currentMax = 第一个区间右端点；
     * 3. 遍历剩余区间：
     * -       - 如果当前区间左端点 > currentMax，说明箭射不到，增加箭数并更新 currentMax；
     * -       - 否则当前区间被当前箭覆盖，继续往下扫描。
     * 为什么只维护一个 currentMax：
     * -  - 当前箭已经射在最右端点，能够覆盖所有与其重叠的区间；
     * -  - 后续区间按右端点排序，只可能在 currentMax 左侧或右侧，
     * -    因此只需更新箭数和 currentMax，历史区间不必存储。
     * 时间复杂度：O(n log n) （排序耗时）
     * 空间复杂度：O(1)
     */
    public static int findMinArrowShots2(int[][] points) {
        if (points.length == 0) {
            return 0;
        }

        // 1. 按右端点升序排序，使得每次选择最右端点的箭覆盖尽量多的气球
        Arrays.sort(points, Comparator.comparingInt(a -> a[1]));

        // 2. 初始化箭的位置在第一个区间右端点
        int currentMax = points[0][1];
        // 至少一支箭
        int res = 1;

        // 3. 遍历后续区间
        for (int i = 1; i < points.length; i++) {
            // 如果当前气球左端点 > currentMax，当前箭射不到，增加一箭
            if (points[i][0] > currentMax) {
                res++;
                // 更新箭的位置为当前气球右端点
                currentMax = points[i][1];
            }
            // 否则当前气球被当前箭覆盖，无需动作
        }

        return res;
    }

}
