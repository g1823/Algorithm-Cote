package leetCode.moderately;

/**
 * @author: gj
 * @description: 1975. 最大方阵和
 */
public class MaxMatrixSum {
    public static void main(String[] args) {
        System.out.println(new MaxMatrixSum().maxMatrixSum(new int[][]{
                {-1, 0, -1},
                {-2, 1, 3},
                {3, 2, 2}}));
    }

    /**
     * - 1. 初始想法及遇到的问题
     * -    - 最初思考：矩阵中每个元素是否需要乘以 -1 与其上下左右元素相关
     * -      -> 反转一个元素会影响周围元素，周围元素又会影响它们的邻居
     * -      -> 局部变化可能导致全局连锁反应，难以判断最优
     * -    - 简单尝试局部贪心：
     * -      * 两正两负考虑交换、取绝对值最大变正等
     * -      * 会产生反复调整和依赖循环
     * -    - 问题核心：
     * -      * 直接模拟局部变化无法保证全局最优
     * -      * 需要找到“全局可控的不变量”
     * -
     * - 2. 思路突破：从全局互相影响转到全局变量
     * -    - 注意到操作规则：
     * -        * 相邻两个元素同时乘以 -1
     * -        * 可重复、可逆、无成本
     * -    - 提问：
     * -        * 有没有操作代价？可否恢复？-> 可以
     * -        * 哪些东西是不可变的？-> 负数个数奇偶性是不可变的
     * -        * 位置重要吗？-> 最大和只关心数值绝对值和，位置无关
     * -    - 结论：
     * -        * 局部耦合是表象，可以抽象为：
     * -            1) 统计负数数量的奇偶性
     * -            2) 找出最小绝对值元素
     * -    - 模板思维（遇到类似问题时可复用）：
     * -        1) 判断操作是否可逆 + 可重复 + 无成本
     * -        2) 找不变量（奇偶、计数、模等）
     * -        3) 判断目标函数是否与位置无关
     * -        4) 不模拟局部过程，直接用全局状态解题
     * -
     * - 3. 0 特殊处理
     * -    - 如果矩阵中存在 0，则：
     * -        * 0 本身符号不会变
     * -        * 可以用负号与 0 相邻操作，将所有负号搬运到 0 的位置
     * -        * 这样最终可以将负数全部消除
     * -    - 所以在有 0 的情况下，无论负数奇偶，都可以得到所有元素为正数
     * -
     * - 4. 负号随意移动证明（严格化）
     * -    - 操作定义：相邻两个元素同时乘以 -1
     * -    - 目标：将某个负号从任意起点移动到任意目标位置
     * -    - 构造方法：
     * -        1) 找到起点到终点的一条相邻路径
     * -        2) 沿路径依次翻转相邻元素
     * -        3) 分析符号变化：
     * -            - 中间经过的元素翻转偶数次 -> 符号恢复
     * -            - 终点元素翻转奇数次 -> 符号最终变为负
     * -        4) 所有其他元素符号最终恢复
     * -    - 结论：负号可以通过连续操作自由移动到矩阵任意元素上
     * -
     * - 5. 解题思路总结
     * -    1) 遍历矩阵：
     * -        - 统计负数数量 count
     * -        - 累加所有元素绝对值 sum
     * -        - 记录最小绝对值 min
     * -        - 判断是否存在 0
     * -    2) 根据规则：
     * -        - 如果存在 0 或 count 为偶数：
     * -            -> 可以将所有元素变为正数
     * -            -> 最大和 = sum
     * -        - 否则（负数个数为奇数且无 0）：
     * -            -> 最小绝对值元素必须为负
     * -            -> 最大和 = sum - 2 * min
     */
    public long maxMatrixSum(int[][] matrix) {
        int n = matrix.length;
        int m = matrix[0].length;
        int count = 0;
        int min = Integer.MAX_VALUE;
        long sum = 0;
        boolean flag = false;
        for (int[] ints : matrix) {
            for (int j = 0; j < m; j++) {
                int num = ints[j];
                if (num == 0) {
                    flag = true;
                }
                if (num < 0) {
                    count++;
                    num = -num;
                }
                sum += num;
                min = Math.min(min, num);
            }
        }
        if (flag || count % 2 == 0) {
            return sum;
        }
        // 注意：这里需要减去2L * min，因此 sum = 除最小值以外其他元素绝对值之和 + 最小值的绝对值， 那么
        // 最终所有元素之和 = 除最小值以外其他元素绝对值之和 - 最小值的绝对值 = sum - 最小值的绝对值 - 最小值的绝对值 = sum - 2L * min
        return sum - 2L * min;
    }
}
