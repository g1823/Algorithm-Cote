package leetCode.moderately;

/**
 * @author: gj
 * @description: 201. 数字范围按位与
 */
public class RangeBitwiseAnd {

    /**
     * LeetCode 201. 数字范围按位与
     * <p>
     * 【核心思考过程】
     * 1. 题意是要求计算：left & (left+1) & ... & right。
     * 暴力遍历会超时，因此必须找到数学规律。
     * <p>
     * 2. AND 按位与的关键性质：
     * —— 某一 bit 位只要在区间内任何一次变成过 0，则最终结果该位一定为 0。
     * 3. 如果尝试对区间内所有数组的每一位进行判断，判断某一位是否出现过0
     * —— 最终会发现跟暴力枚举没有任何区别，因此舍弃。
     * <p>
     * 4. 因此关键点是：判断区间 [left, right] 的某一位是否“稳定”。
     * —— 如果该位在此区间内发生过变化（从 0→1 或 1→0），那么区间某个数字上该位必为 0，所以最终结果为 0。
     * —— 即区间内所有数字在某一位上是否全为1，未出现过0.
     * <p>
     * 5. 思考区间数值变化特点：
     * 区间内的数字是连续的，即从left一次+1，直到加到right。
     * 若left 和 right的前缀相同，为"xxx",那么left = xxx0...，而right = xxx1...
     * 此时，left想要从xxx0...变为xxx1...，则必然会经历从xxx0111(后续全1) + 1 变为 xxx 1(后续全0)的步骤，则意味着后续所有位全部都会出现0.
     * 那么，最终也就只有前缀和“xxx"中不为1的位置最终稳定了，即结果就是"xxx"00000了
     * 将整数加 1 时，从最低位开始连锁翻转：
     * ...011111  +1 →  ...100000
     * 一旦跨越某个二进制边界（如 0111→1000），变化位及其右侧所有位都会经历 0。
     * <p>
     * 6. 因此得出关键结论：
     *  “最右侧的变化位及其右侧全部不稳定 = 最终全部为 0”
     * <p>
     * 7. 变化位如何判断？
     * —— 只要 left 与 right 在某一 bit 上不同，则该 bit 在区间内一定发生过变化。
     * —— 因为 left < right，若该位不同，肯定跨越了该位的二进制边界。
     * <p>
     * 8. 所以：
     * ✔ 从高位往低位扫描
     * ✔ 若 left 与 right 在 bit i 上相同 → 属于公共前缀，可保留
     * ✔ 若首次遇到不同的 bit → 此位及其右边全部必须为 0 → 可以直接 break
     * <p>
     * 6. 结论：
     * 最终答案 = left 与 right 的“公共前缀”，其余位全为 0。
     * <p>
     * 【本实现】
     * 采用从高位到低位逐位判断，逻辑清晰、与你原有写法风格一致，
     * 并且利用了“遇到第一处差异即可退出”的关键性质，效率优于右移算法。
     */
    public int rangeBitwiseAnd(int left, int right) {
        // 如果 left==right，区间里只有一个数字
        if (left == right) {
            return left;
        }
        int res = 0;
        // 自高位到低位（Java int 最高位是 bit 31）
        for (int i = 31; i >= 0; i--) {
            int bitLeft = left & (1 << i);
            int bitRight = right & (1 << i);
            // 如果这一位在 left 和 right 上不同：
            // 表示本位是“变化位”，本位以及右侧都应为 0
            if (bitLeft != bitRight) {
                break; // 更低位都不用看了
            }
            // 相同则这位属于公共前缀，可直接加到结果里
            res |= bitLeft;
        }

        return res;
    }

}
