package leetCode.simple;

/**
 * @author: gj
 * @description: 190. 颠倒二进制位
 */
public class ReverseBits {
    public static void main(String[] args) {
        System.out.println(new ReverseBits().reverseBits(10));
    }

    /**
     * 错误示范写法的问题总结：
     * 1. 使用 while(n > 0) 导致循环提前结束
     * - 位反转必须处理完整的 32 位。
     * - while(n > 0) 在 n 变为 0 时就停止，导致高位的所有 0 没被处理，结果缺失反转后的前导 0。
     * - 例如：00000000000000000000000000000001 逾期转为： 10000000000000000000000000000000， 然而第一次循环后就会结束，只能得到：00000000000000000000000000000001
     * 2. 使用算术右移 >> 会发生符号扩展
     * - 当 n 为负数时，>> 会在左侧补 1，使 n 永远不会变成 0。
     * - 导致循环可能变成死循环，或不断加入错误的高位 1。
     * - 正确做法应使用逻辑右移 >>>，保证左侧补 0。
     * - 例如：10000000 00000000 00000000 00000001 算术右移会补 1：11000000 00000000 00000000 00000000，最终会无限循环
     * 3. 循环次数不固定导致结果位移错乱
     * - result 每次都会左移一位，因此循环次数必须固定为 32 次。
     * - 若以 n > 0 作为循环条件，循环次数不固定，会造成最终 result 的位数与目标不一致。
     * <p>
     * 以上三个问题导致该写法在处理符号位、前导零、负数等情况时产生错误，不能正确完成 32 位二进制反转。
     */
    public int reverseBits(int n) {
        int result = 0;
        do {
            result = result << 1;
            int i = n & 1;
            result += i;
            n = n >> 1;
        }
        while (n > 0);
        return result;
    }

    /**
     * 循环32次，将低位换到高位
     */
    public int reverseBits2(int n) {
        int result = 0;
        for (int i = 0; i < 32; i++) {
            result <<= 1;
            result |= (n & 1);
            n >>= 1;
        }
        return result;
    }


    /**
     * TODO：记录
     * 使用“分治/分块交换”方式反转 32 位二进制位。
     * 【核心思想】
     * 将 32 位整数视为由多个小块组成，通过不断交换这些小块最终达到全体反转的效果。
     * 分治步骤为：
     * - 先交换高 16 位与低 16 位
     * - 再交换每个 8 位块（字节）
     * - 再交换每个 4 位块（半字节）
     * - 再交换每个 2 位块
     * - 最后交换每个相邻 bit
     * 每一步都是“并行”交换，比逐位循环快（常数复杂度更小），非常常见的优化写法。
     * 【为什么这种方法正确 —— 思考过程】
     * 1. 朴素方法是每次取 n 的最低位 append 到结果 res 中，循环 32 次即可。
     * 2. 进一步优化时发现：这些操作都是确定的固定模式，可以用掩码 + 位移一次完成一类交换。
     * 例如要交换所有偶数位与奇数位，可以：
     * (n >>> 1) & 0x55555555   —— 得到所有奇数位的值，放到偶数位上
     * (n & 0x55555555) << 1    —— 得到所有偶数位的值，放到奇数位上
     * 两者或起来即可完成“全局的相邻 bit 交换”。
     * 3. 按此思想，把32位不断拆成更小块，直到最后 1 位块，就能完全反转整个 32 位。
     * 【各个掩码作用】
     * 0x55555555 : 二进制 0101...0101  —— 用于奇偶位交换
     * 0x33333333 : 二进制 0011...0011  —— 用于每 2 bit 块交换
     * 0x0f0f0f0f : 二进制 0000_1111...  —— 用于每 4 bit 块交换
     * 0x00ff00ff : 每 8 bit 块交换
     * 0x0000ffff : 高 16 位与低 16 位交换
     * 【时间复杂度】
     * O(1)，固定常数次数的位运算。
     * 【适用场景】
     * - 大量调用 reverseBits（高性能需求）
     * - 对性能极度敏感的系统（网络包处理、底层数据结构、位运算优化）
     */
    public int reverseBits3(int n) {
        // 交换相邻 bit：偶数位 ↔ 奇数位
        n = ((n >>> 1) & 0x55555555) | ((n & 0x55555555) << 1);

        // 交换每 2 bit 块
        n = ((n >>> 2) & 0x33333333) | ((n & 0x33333333) << 2);

        // 交换每 4 bit 块（半字节）
        n = ((n >>> 4) & 0x0f0f0f0f) | ((n & 0x0f0f0f0f) << 4);

        // 交换每 8 bit（字节）
        n = ((n >>> 8) & 0x00ff00ff) | ((n & 0x00ff00ff) << 8);

        // 交换高 16 位与低 16 位
        n = (n >>> 16) | (n << 16);

        return n;
    }

}
