package leetCode.difficult;

/**
 * @author: gj
 * @description: 188. 买卖股票的最佳时机 IV
 */
public class MaxProfit4 {
    /**
     * 实际上就是将原来买卖股票的最佳时机 III中的交易两次改为交易k次
     * 本质上的解题思路没有变化，只是状态变多了，原来III中状态是这样定义的：
     * -    buy0  ：完成 0 次卖出，【持有】股票
     * -    sell1 ：完成 1 次卖出，【不持有】股票
     * -    buy1  ：完成 1 次卖出，【持有】股票
     * -    sell2 ：完成 2 次卖出，【不持有】股票
     * 我们可以将上述状态扩展到交易k次：
     * - 每一天都有 持有股票 和 不持有股票 两种状态
     * - 每一天都有 0 次、1 次、2 次、...、k 次交易
     * - 那么，两种状态组合就是最终每天的状态。
     * - 其中：
     * -    对于持有股票而言，可已完成0次、1次、2次、...、k-1次交易，即第一次买入未卖出，完成0次交易；在完成了k次交易后，就不能再持有股票了，因此 0 <= i < k
     * -    对于不持有股票而言，可以完成0次、1次、2次、...、k次交易，但0次交易表示未交易且不持有股票，即啥也没看，恒等于0；而完成k次交易后，状态只能为不持有股票。因此 0< i <= k.
     * -    对于不持有股票而言，i=0的状态去掉，这样可以保持和buy一样，一共有k种状态。
     * - 状态定义：
     * -    buy[i]：完成 i 次卖出(交易)，【持有】股票的最大收益 (0<= i < k)
     * -    sell[i]：完成 i 次卖出(交易)，【不持有】股票的最大收益 (0< i <= k)
     * 接下来，就是思考状态转移方程：
     * - 今天的buy[i] = 今天完成 i 次卖出(交易),【持有】股票的最大收益
     * -    = max( 昨天完成 i 次卖出(交易),【持有】股票的最大收益，今天啥也不做 , 昨天完成 i 次卖出(交易),【不持有】股票的最大收益，今天买入股票的最大收益 )
     * -    = max( 昨天buy[i], 昨天sell[i] - 今日股票价格)
     * - 今天的sell[i] = 今天完成 i 次卖出(交易),【不持有】股票的最大收益
     * -    = max( 昨天完成 i 次卖出(交易),【不持有】股票的最大收益，今天啥也不做 , 昨天完成 i-1 次卖出(交易),【持有】股票的最大收益，今天卖出股票的最大收益 )
     * -    = max( 昨天sell[i], 昨天buy[i-1] + 今日股票价格)
     * 接下来思考状态转移的顺序：
     * - 根据上面分析，可以看到：
     * -    新buy[i] 依赖 旧buy[i] 和 旧sell[i]
     * -    新sell[i] 依赖 旧sell[i] 和 旧buy[i-1]
     * - 可以看到，buy[i] 需要使用 旧sell[i] ，sell[i] 需要使用 旧buy[i-1]，
     * - 因此，更新顺序必须先更新 buy[i] ，再更新 sell[i]，先更新 i ，再更新 i-1
     * - 即：更新顺序必须先更新 buy[i] ，再更新 sell[i]
     * 状态转移方程：
     * - buy[i] = max( 昨天buy[i], 昨天sell[i] - 今日股票价格)
     * - sell[i] = max( 昨天sell[i], 昨天buy[i-1] + 今日股票价格)
     * 状态初始化：
     * - 未开始进行时，也就是第0天之前，不可能持有股票，因此buy[i] = Integer.MIN_VALUE
     * - 未开始进行时，也就是第0天之前，不持有股票，即什么都没做，因此sell[i] = 0
     * 注意：
     * 1、因为 i = 0 的时候，i-1非法，且sell[0] 恒等于 0，因此一般更新状态时， j>0 ，那么就需要单独更新一下 buy[0],因为当 j=1 时，sell[j]依赖buy[0]。
     * 2、当k>= n/2时，相当于可以每天都买入，第二天卖出了。那么就相当于没有次数限制了，实际上就退化为了122. 买卖股票的最佳时机 II,那么就可以采用贪心解法了
     */
    public int maxProfit(int k, int[] prices) {
        int n = prices.length;
        if (n <= 1) {
            return 0;
        }
        if (k >= n / 2) {
            int profit = 0;
            for (int i = 1; i < prices.length; i++) {
                if (prices[i] > prices[i - 1]) {
                    profit += prices[i] - prices[i - 1];
                }
            }
            return profit;
        }
        int[] buy = new int[k + 1];
        int[] sell = new int[k + 1];
        for (int i = 0; i <= k; i++) {
            buy[i] = Integer.MIN_VALUE;
            sell[i] = 0;
        }
        for (int i = 0; i < n; i++) {
            // 第一次买入，下面循环中 j>0 ，sell[0]理论上恒等于0，不需要更新
            // 而buy[0]却不一定，可以任意一天第一次买入，所以在外层初始化一下
            buy[0] = Math.max(buy[0], -prices[i]);
            for (int j = k; j > 0; j--) {
                buy[j] = Math.max(buy[j], sell[j] - prices[i]);
                sell[j] = Math.max(sell[j], buy[j - 1] + prices[i]);
            }
        }
        return sell[k];
    }
}
