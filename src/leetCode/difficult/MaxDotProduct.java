package leetCode.difficult;

/**
 * @author: gj
 * @description: 1458. 两个子序列的最大点积
 */
public class MaxDotProduct {

    /**
     * 动态规划：
     * - 思考过程整理（从蛮力到动态规划）：
     * - 一、最初的蛮力思路（被否定）
     * - ------------------------------------------------
     * - 直觉上可以从“选 1 个、选 2 个、选 3 个……”入手，
     * - 枚举两个数组中所有长度相同的子序列，计算点积取最大值。
     * -
     * - 但很快会发现几个问题：
     * - 1）不同长度的枚举存在大量重复计算：
     * -    - 长度为 k、k+1、k+2 时，前 k 个元素的点积会被反复计算
     * - 2）“按长度枚举”并不是子序列问题的本质，
     * -    子序列的核心在于：当前位置的元素“选 or 不选”，而不是选了几个
     * -
     * - 因此，按长度枚举本身就是一个错误的切入角度。
     * -
     * - 二、尝试贪心的直觉（再次被否定）
     * - ------------------------------------------------
     * - 一个看似合理的想法是：
     * - - 如果 nums1[i] * nums2[j] < 0，那么它对结果是负贡献，是否可以直接跳过？
     * -
     * - 但这个想法忽略了一个关键约束：
     * - - 题目要求：必须选择“至少一对”元素
     * -
     * - 如果两个数组的所有乘积都是负数，
     * - 那么答案也必须是“最不负的那一个”，而不是 0 或不选。
     * -
     * - 这说明：
     * - - “负数贡献”并不能简单地一律跳过
     * - - 是否选择当前这一对，取决于：
     * -   - 这是第一对？
     * -   - 还是接在已有结果后面？
     * -
     * - 贪心（只看当前乘积的正负或大小）是行不通的。
     * -
     * - 三、重新抽象问题：子序列 + 必须选 + 有负数
     * - ------------------------------------------------
     * - 关键认知转变：
     * - - 不能从“选几个”出发
     * - - 而应该从“当前这一对是否参与最终解”出发
     * -
     * - 因此考虑动态规划，用前缀来描述状态。
     * -
     * - 四、状态定义
     * - ------------------------------------------------
     * - dp[i][j] 表示：
     * - - 在 nums1[0..i] 和 nums2[0..j] 这两个前缀中
     * - - 能得到的最大点积
     * - - 并且隐含约束：至少已经选过一对元素
     * -
     * - 这个定义非常关键，它决定了：
     * - - dp 不能随意初始化为 0
     * - - “什么都不选”不是一个合法状态
     * -
     * - 五、状态转移的完整拆解
     * - ------------------------------------------------
     * - 在位置 (i, j)，只有三类互斥且完备的选择：
     * - 1）选择 nums1[i] 和 nums2[j] 这一对
     * -    - 这是第一对：
     * -        nums1[i] * nums2[j]
     * -    - 或者接在之前的最优解后面：
     * -        dp[i-1][j-1] + nums1[i] * nums2[j]
     * -
     * -    因此“选当前这一对”的最优值是：
     * -        max(nums1[i] * nums2[j],
     * -            dp[i-1][j-1] + nums1[i] * nums2[j])
     * -
     * - 2）不使用 nums1[i]
     * -    - 当前最优解已经出现在更小的前缀中
     * -    - 直接继承 dp[i-1][j]
     * -
     * - 3）不使用 nums2[j]
     * -    - 同理，继承 dp[i][j-1]
     * -
     * - dp[i][j] 就是以上三种情况的最大值。
     * -
     * - 六、边界处理的思考
     * - ------------------------------------------------
     * - 第一行（i == 0）：
     * - - 只能在 nums1[0] 和 nums2[0..j] 中选一对
     * - - 要么选 (0, j)
     * - - 要么沿用 dp[0][j-1]
     * -
     * - 第一列（j == 0）同理。
     * -
     * - 这些边界处理的本质，仍然是：
     * - - “选当前这一对”
     * - - 或“继承之前已经算出的最优解”
     * -
     * - 总结：
     * - ------------------------------------------------
     * - 本题的核心难点不在代码，而在思维：
     * - - 必须允许“从当前重新开始选第一对”
     * - - 必须防止“默认 0”导致非法空子序列被选中
     * - - 必须区分：
     * -   - 选当前这一对
     * -   - 与“不选任何一个，继承历史最优解”
     * -
     * - 一旦这些语义想清楚，DP 转移自然成立。
     */
    public int maxDotProduct(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;
        // dp[i][j]表示：nums1[0...i]与nums2[0...j]的最大点积
        int[][] dp = new int[m][n];
        // 初始化
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 当i=0时，nums1[0]与nums2[0...j]的点积为Max(nums1[0] * nums2[j], dp[0][j])，即nums1[0]与nums2的前j个元素中最大点积
                if (i == 0) {
                    dp[i][j] = j == 0 ? nums1[0] * nums2[0] : Math.max(nums1[0] * nums2[j], dp[0][j - 1]);
                    continue;
                }
                // 当j=0时，nums1[0...i]与nums2[0]的点积为Max(nums1[i] * nums2[0], dp[i][0])，即nums1的前i个元素与nums2[0]的点积
                if (j == 0) {
                    dp[i][j] = Math.max(nums1[i] * nums2[0], dp[i - 1][0]);
                    continue;
                }
                // 选择当前两个数字
                int select = Math.max(dp[i - 1][j - 1] + nums1[i] * nums2[j], nums1[i] * nums2[j]);
                // 不要任意一个数字
                int notSelect = Math.max(dp[i - 1][j], dp[i][j - 1]);
                dp[i][j] = Math.max(select, notSelect);
            }
        }
        return dp[m - 1][n - 1];
    }

    /**
     * 空间优化：
     * - 可以发现，dp[i][j] 只和 dp[i-1][j]、dp[i][j-1]、dp[i-1][j-1] 有关
     * - 即只和上一行的元素以及当前行左侧元素有关，那么可以空间优化为 O(n)，改为一维滚动数组
     * - 那么就需要记录一下dp[i-1][j-1]的值
     */
    public int maxDotProduct2(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;
        // dp[j] 表示：当前行（i）下，nums1[0..i] 与 nums2[0..j] 的最大点积
        int[] dp = new int[n];
        for (int i = 0; i < m; i++) {
            // 用来保存 dp[i-1][j-1]
            int prev = Integer.MIN_VALUE;
            for (int j = 0; j < n; j++) {
                // 暂存 dp[i-1][j]，下一轮会变成 prev
                int temp = dp[j];
                int product = nums1[i] * nums2[j];
                if (i == 0 && j == 0) {
                    // 第一格：只能选这一对
                    dp[j] = product;
                } else if (i == 0) {
                    // 第一行：nums1[0] 与 nums2[0..j]
                    dp[j] = Math.max(product, dp[j - 1]);
                } else if (j == 0) {
                    // 第一列：nums1[0..i] 与 nums2[0]
                    dp[j] = Math.max(product, dp[j]);
                } else {
                    // 选当前这一对：
                    // 1）单独作为第一对
                    // 2）接在 dp[i-1][j-1] 后面
                    int select = Math.max(product, prev + product);
                    // 不选当前某一个，继承历史最优
                    int notSelect = Math.max(dp[j], dp[j - 1]);

                    dp[j] = Math.max(select, notSelect);
                }
                // 更新 dp[i-1][j-1]
                prev = temp;
            }
        }
        return dp[n - 1];
    }
}
