package leetCode.difficult;

/**
 * @author: gj
 * @description: 123. 买卖股票的最佳时机 III
 */
public class MaxProfit3 {

    /**
     * - 一、与 122. 买卖股票的最佳时机 II 的区别理解
     * -    122 的前提：
     * -       交易次数不受限制
     * -       可以使用贪心策略：只要今天比昨天价格高，就把差价累加
     * -    123 的新增约束：
     * -       最多只能完成 2 次交易（一次交易 = 买入 + 卖出）
     * -    关键影响：
     * -       全局“交易次数上限”会破坏贪心选择性质
     * -       过早卖出，可能浪费交易次数
     * -       局部最优（今天赚一点）不一定是全局最优
     * -    结论：
     * -       123 不能在 122 的解法上简单加 count
     * -       必须显式建模「交易次数」这个状态
     * - 二、状态建模的演化过程
     * -    初始直觉：
     * -       状态 = 是否持有股票 + 已完成交易次数
     * -    枚举所有理论状态：
     * -       持有股票，交易 0 次
     * -       持有股票，交易 1 次
     * -       不持有股票，交易 0 次
     * -       不持有股票，交易 1 次
     * -       不持有股票，交易 2 次
     * -    剪枝非法状态：
     * -       不存在「持有股票 + 已完成 2 次交易」
     * -      - 因为完成 2 次交易后不能再买入
     * -    进一步观察：
     * -       不持有股票，交易 0 次收益恒等于 0
     * -       只作为“第一次买入”的基准状态，不需要维护
     * -    最终需要维护的 4 个核心状态：
     * -       buy0  ：完成 0 次卖出，当前【持有】股票
     * -       sell1 ：完成 1 次卖出，当前【不持有】股票
     * -       buy1  ：完成 1 次卖出，当前【持有】股票
     * -       sell2 ：完成 2 次卖出，当前【不持有】股票
     * - 三、关键认知修正：交易次数只在「卖出」时增加
     * -    最开始的错误理解：
     * -       尝试在“买入”时增加交易次数
     * -       出现同一天先卖出再买入的非法状态转移
     * -    修正后的正确定义：
     * -       买入：只是进入一笔交易，不代表交易完成，不增加交易次数
     * -       卖出：一次交易完成，交易次数 +1
     * -    结论：
     * -       buyX 的转移不增加交易次数
     * -       sellX 的转移一定来自 buy(X-1)
     * - 四、从 DP 数组到「状态机（变量）」的转化
     * -    原始 DP 形式：
     * -       dp[i][state] 只依赖 dp[i-1][state]
     * -    关键观察：
     * -       当前天的状态只依赖前一天
     * -       不依赖更早的历史
     * -    推论：
     * -       不需要完整 dp 数组
     * -       可以用有限个变量滚动维护状态
     * -    本题中：
     * -       dp 状态压缩为 4 个变量
     * - 五、状态转移方程（语义理解）
     * -    sell2：
     * -       保持昨天已完成 2 次交易状态
     * -       或昨天完成 1 次交易且持股，今天卖出完成第 2 次交易
     * -    buy1：
     * -       保持昨天完成 1 次交易且持股
     * -       或昨天完成 1 次交易且不持股，今天买入开启第二笔交易
     * -    sell1：
     * -       保持昨天已完成 1 次交易
     * -       或昨天完成 0 次交易且持股，今天卖出完成第 1 次交易
     * -    buy0：
     * -       保持昨天已买入但未卖出状态
     * -       或从“不持股 + 0 次交易”的基准状态，今天第一次买入
     * - 六、状态更新顺序（非常关键）
     * -    问题：
     * -       所有状态存放在变量中
     * -       如果更新顺序不当，会使用到“今天刚更新的状态”
     * -       等价于允许同一天多次交易
     * -    状态依赖关系：
     * -       sell2 依赖 buy1
     * -       buy1  依赖 sell1
     * -       sell1 依赖 buy0
     * -       buy0  依赖常量 0
     * -    解决方案：
     * -       按反向拓扑顺序更新
     * -       更新顺序必须是：sell2 → buy1 → sell1 → buy0
     * - 七、初始化逻辑
     * -    buy0、buy1：
     * -       初始时不可能持有股票，用 Integer.MIN_VALUE 表示非法状态
     * -    sell1、sell2：
     * -       在什么都没做之前，不持股收益为 0
     * - 八、最终答案的选择
     * -    最终利润必须来自不持股状态
     * -    结果为 max(sell1, sell2)
     */
    public int maxProfit(int[] prices) {
        int n = prices.length;
        // 完成 0 次卖出，当前持有股票（第一次买入后）
        int buy0 = Integer.MIN_VALUE;
        // 完成 1 次卖出，当前持有股票（第二次买入后）
        int buy1 = Integer.MIN_VALUE;
        // 完成 1 次卖出，当前不持有股票（第一次卖出后）
        int sell1 = 0;
        // 完成 2 次卖出，当前不持有股票（第二次卖出后）
        int sell2 = 0;

        for (int i = 0; i < n; i++) {
            int price = prices[i];
            // 第二次卖出：由 buy1 卖出，或保持原状态
            sell2 = Math.max(sell2, buy1 + price);
            // 第二次买入：由 sell1 买入，或保持原状态
            buy1 = Math.max(buy1, sell1 - price);
            // 第一次卖出：由 buy0 卖出，或保持原状态
            sell1 = Math.max(sell1, buy0 + price);
            // 第一次买入：从 0 状态买入，或保持原状态
            buy0 = Math.max(buy0, -price);
        }

        // 最终必须不持股，取最多完成 1 次或 2 次交易的最大值
        return Math.max(sell1, sell2);
    }
}
