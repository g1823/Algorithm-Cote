package leetCode.difficult;

import java.util.HashMap;
import java.util.Map;

/**
 * @author: gj
 * @description: 149. 直线上最多的点数
 */
public class MaxPoints {
    /**
     * 149. 直线上最多的点数
     * 【整体思考过程】
     * 1、最初直觉（错误但自然的想法）
     * ------------------------------------------------
     * 一条直线在解析几何中可以表示为：y = kx + b
     * 因此似乎可以用 (k, b) 唯一确定一条直线。
     * 但如果这样做：
     * - 任意两点确定一条直线
     * - 再遍历所有点，判断是否在该直线上
     * 时间复杂度会达到 O(n³)，必然超时。
     * 2、关键转折：不再“全局表示直线”，而是“局部统计”
     * ------------------------------------------------
     * 换一个视角：
     * - 不去全局枚举所有直线
     * - 而是【固定一个点 i】
     * - 只考虑“所有经过点 i 的直线”
     * 重要结论：
     * 👉 所有经过同一个点的直线，只需要用【斜率】区分
     * 👉 截距 b 在这里完全不需要
     * 3、固定一个点后的问题转化
     * ------------------------------------------------
     * 对于固定点 i：
     * - 任意另一点 j，都可以和 i 确定一条直线
     * - 这条直线可以用 “斜率” 表示
     * 因此：
     * - 遍历所有 j
     * - 统计「每种斜率出现的次数」
     * - 出现次数最多的斜率，对应的就是
     * -  “经过点 i，且经过点最多的一条直线”
     * 4 为什么整体复杂度是 O(n²)，而不是 O(n³)
     * ------------------------------------------------
     * 外层：固定点 i（n 次）
     * 内层：遍历点 j（n 次）
     * 在内层中：
     * - 计算斜率
     * - 在 map 中计数
     * 所有统计都是“边遍历边完成”，没有第三层循环
     * 👉 总时间复杂度 = O(n²)
     * 5️⃣ 斜率不能用 double（关键坑点）
     * ------------------------------------------------
     * 使用 double 表示斜率会遇到：
     * - 精度误差
     * - 数学上相等的斜率，在 double 中不一定相等
     * 解决方案：
     * 👉 用最简分数形式表示斜率
     * 👉 用 (dy, dx) 作为斜率的唯一表示
     * 6️⃣ 特殊情况必须单独处理
     * ------------------------------------------------
     * - 重合点（坐标完全相同）
     * -  → 它们可以落在任意直线上，需要单独计数
     * - 竖线（dx = 0）
     * - 横线（dy = 0）
     * 这些情况都需要统一规范表示，保证不会出现多个 key 表示同一斜率
     * 7️⃣ 最终结果如何得到
     * ------------------------------------------------
     * 对于每一个固定点 i：
     * - 统计 map 中出现次数最多的斜率 curMax
     * - 再加上与 i 重合的点数 same
     * 在所有点 i 中取最大值，即为答案
     */
    public int maxPoints(int[][] points) {
        int n = points.length;
        if (n <= 2) {
            // 点数 <= 2 时，所有点必然共线
            return n;
        }
        int res = 0;
        // 外层：固定一个点作为“锚点”
        for (int i = 0; i < n; i++) {
            /**
             * key：斜率的最简形式 "dy/dx"
             * value：具有该斜率的点的数量
             *
             * 注意：
             * - 这里只统计“不同点”形成的斜率
             * - 重合点不放进 map
             */
            Map<String, Integer> map = new HashMap<>();
            // 与 points[i] 重合的点数（包含自身）
            int same = 1;
            int curMax = 0;
            int x1 = points[i][0];
            int y1 = points[i][1];
            // 内层：遍历其他点
            for (int j = i + 1; j < n; j++) {
                int x2 = points[j][0];
                int y2 = points[j][1];
                //重合点：单独统计
                if (x1 == x2 && y1 == y2) {
                    same++;
                    continue;
                }
                //计算方向向量
                int dx = x2 - x1;
                int dy = y2 - y1;
                //使用 gcd 将 (dy, dx) 规约成最简比例
                int g = gcd(dx, dy);
                dx /= g;
                dy /= g;
                /**
                 * 统一符号
                 * 为了保证同一斜率只对应一个 key：
                 * - 规定 dx >= 0
                 * - 若 dx < 0，则整体取反
                 */
                if (dx < 0) {
                    dx = -dx;
                    dy = -dy;
                }
                // 处理竖线：dx = 0
                // 所有竖线统一表示为 (dy = 1, dx = 0)
                if (dx == 0) {
                    dy = 1;
                }
                // 处理横线：dy = 0
                // 所有横线统一表示为 (dy = 0, dx = 1)
                if (dy == 0) {
                    dx = 1;
                }
                // 将斜率作为 key 放入 map
                String key = dy + "/" + dx;
                int cnt = map.getOrDefault(key, 0) + 1;
                map.put(key, cnt);
                // 维护当前锚点下的最大斜率点数
                curMax = Math.max(curMax, cnt);
            }
            /**
             * 对于当前锚点：
             * - curMax：最多有多少“不同点”与其共线
             * - same：与其重合的点数
             * 重合点必然也在这条直线上，因此需要相加
             */
            res = Math.max(res, curMax + same);
        }

        return res;
    }

    /**
     * 求最大公约数（欧几里得算法）
     * 用于将 (dx, dy) 规约为最简比例，
     * 确保同一斜率只对应一个唯一表示。
     */
    private int gcd(int a, int b) {
        if (b == 0) {
            return a;
        }
        return gcd(b, a % b);
    }

}
